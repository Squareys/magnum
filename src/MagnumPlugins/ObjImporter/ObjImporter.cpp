/*
    This file is part of Magnum.

    Copyright © 2010, 2011, 2012, 2013, 2014, 2015, 2016, 2017, 2018
              Vladimír Vondruš <mosra@centrum.cz>

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

#include "ObjImporter.h"

#include <fstream>
#include <limits>
#include <sstream>
#include <tuple>
#include <stdlib.h>
#include <unordered_map>
#include <Corrade/Containers/ArrayView.h>
#include <Corrade/Utility/String.h>
#include <Corrade/Utility/Directory.h>

#include "Magnum/Mesh.h"
#include "Magnum/MeshTools/CombineIndexedArrays.h"
#include "Magnum/MeshTools/Duplicate.h"
#include "Magnum/Math/Vector3.h"
#include "Magnum/Math/Color.h"
#include "Magnum/Trade/MeshData3D.h"
#include "Magnum/Trade/MeshObjectData3D.h"
#include "Magnum/Trade/ImageData.h"
#include "Magnum/Trade/PhongMaterialData.h"

#include "MagnumPlugins/TgaImporter/TgaImporter.h"

using namespace Corrade::Containers;

namespace Magnum { namespace Trade {


/* Not using PhongMaterialData, since we may want to set color and texture to
 * later decide which flags we set. We do not know whether we have a texture
 * or color beforehand. */
struct ObjMaterial {
    std::string name;
    Color3 ambient;
    Color3 diffuse;
    Color3 specular;
    Float specularity;
    Int ambientTexture = -1;
    Int diffuseTexture = -1;
    Int specularTexture = -1;
};

struct ObjObject;
struct ObjGroup;
struct ObjMesh;

struct ObjMeshData {
    ObjGroup& group;
    int materialId; /* from 'usemtl' keyword */

    ObjMesh* points = nullptr;
    ObjMesh* lines = nullptr;
    ObjMesh* faces = nullptr;

    ObjMeshData()=delete;
    ObjMeshData(ObjGroup& g, int matId): group(g), materialId(matId) {}
};

struct ObjGroup {
    ObjObject& object;
    std::string name; /* from 'g' keyword */

    std::vector<std::unique_ptr<ObjMeshData>> meshes;
    std::unordered_map<int, int> meshPerMaterial;

    ObjGroup()=delete;
    ObjGroup(ObjObject& o): object(o) {}

    /* Create or get mesh for given material id */
    ObjMeshData& meshDataForMaterial(int materialId) {
        if(meshPerMaterial.find(materialId) != meshPerMaterial.end()) {
            return *meshes[meshPerMaterial[materialId]];
        } else {
            meshPerMaterial[materialId] = meshes.size();
            meshes.emplace_back(new ObjMeshData{*this, materialId});
            ObjMeshData& mesh = *meshes.back();
            return mesh;
        }
    }
};

struct ObjObject {
    std::string name; /* from 'o' keyword */
    std::vector<std::unique_ptr<ObjGroup>> groups;

    ObjObject(): name{""} {}
    ObjObject(ArrayView<char> name): name{name.data(), name.size()} {}
};

/* An intermediate object representing a mesh and it's properties as well as
 * where to find the data associated to it */
struct ObjMesh {
    ObjMeshData& data; /* parent object containing data shared meshes for different primitives */
    MeshPrimitive primitive;

    /* Sections of the file belonging to this mesh */
    std::vector<ArrayView<char>> sections;

    int minPrimitives = 0; /* For smarter vector memory allocation later */

    ObjMesh(ObjMeshData& d, MeshPrimitive p): data(d), primitive(p) {}

    std::string name() {
        std::string name = data.group.object.name;

        if(!data.group.name.empty()) {
            name += ":" + data.group.name;
        }

        if(data.materialId != -1) {
            name += "$" + std::to_string(data.materialId);
        }

        const int numPrimitiveTypes =
            ((data.points) ? 1 : 0)
            + ((data.lines) ? 1 : 0)
            + ((data.faces) ? 1 : 0);
        if(numPrimitiveTypes > 1) {
            std::ostringstream out;
            Debug(&out) << primitive;
            name += "%" + out.str();
        }

        return name;
    }
};


/* The state of the imported generated by openData() */
struct ImporterState {
    std::vector<ObjMaterial> materials;
    std::unordered_map<std::string, int> materialIds;

    std::vector<std::string> textures;
    std::unordered_map<std::string, int> textureIds;

    std::vector<std::unique_ptr<ObjObject>> objects;

    std::vector<std::unique_ptr<ObjMesh>> meshes;
    std::unordered_map<std::string, int> meshIds;

    std::vector<std::string> meshlessObjects;
    std::unordered_map<std::string, int> meshlessObjectIds;

    std::vector<Vector3> positions;
    std::vector<Vector2> texCoords;
    std::vector<Vector3> normals;
};

namespace {

int strToInt(const ArrayView<char> str) {
    char* err;
    const int i = int(strtol(str.data(), &err, 10));
    if(err == nullptr) {
        Error() << "Trade::ObjImporter::mesh3D(): error while converting numeric data";
        return 0;
    }

    return i;
}

float strToFloat(const ArrayView<char> str) {
    char* err;
    const float f = strtof(str.data(), &err);
    if(err == nullptr) {
        Error() << "Trade::ObjImporter::mesh3D(): error while converting numeric data";
        return 0;
    }

    return f;
}

// find first index of c in pos, cancel search at newline or whitespace if flag set.
int findNext(const ArrayView<char> pos, char c, bool termByNewline=false, bool termByWhitespace=false) {
    const int size = pos.size();
    for(int i = 0; i < size; ++i) {
        if(pos[i] == c) {
            return i;
        }

        if((pos[i] == '\n' && termByNewline) || (pos[i] == ' ' && termByWhitespace)) {
            return -1;
        }
    }
    return -1;
}

// find next non-whitespace char and return suffix at that point.
// param newlineIsWhitespace if "true", '\n' and '\r' are skipped also
ArrayView<char> skipWhitespaces(const ArrayView<char> pos, bool newlineIsWhitespace=true) {
    const int size = pos.size();
    for(int i = 0; i < size; ++i) {
        const char c = pos[i];
        if(c != ' ' && c != '\t' && c != '\0' && (!newlineIsWhitespace || (c != '\n'  && c != '\r'))) {
            return pos.suffix(i);
        }
    }
    return {};
}

// returns suffix after next '\n'
ArrayView<char> ignoreLine(const ArrayView<char> pos) {
    return pos.suffix(findNext(pos, '\n') + 1);
}

// same as ignoreLine, but also returns the content "ignored".
// Different description: Get string until next '\n' and return ArrayView of data
// after it.
std::tuple<ArrayView<char>, ArrayView<char>> nextLine(const ArrayView<char>& pos) {
    int i = Math::min(findNext(pos, '\n'), findNext(pos, '\r'));
    if(i == -1)         {
        i = pos.size();
        return std::make_tuple(pos.prefix(i), pos.suffix(i));
    }
    return std::make_tuple(pos.prefix(i), pos.suffix(i+1));
}

bool atEndOfLine(const ArrayView<char> pos) {
    int i = 0;
    while(pos[i] == ' ') ++i;

    return (pos[i] == '\n' || pos[i] == '\r');
}

// get string of content until next ' ' and also return ArrayView for data after the word.
std::tuple<ArrayView<char>, ArrayView<char>> nextWord(const ArrayView<char> pos) {
    int i = 0;
    const int size = pos.size();
    for(; i < size; ++i) {
        if(pos[i] == ' ' || pos[i] == '\r' || pos[i] == '\n' || pos[i] == '\0') {
            break;
        }
    }
    return std::make_tuple(pos.prefix(i), pos.suffix(i));
}

std::tuple<std::array<int, 2>, ArrayView<char>> parseLine(const ArrayView<char> pos) {
    std::array<int, 2> indices{0, 0};
    ArrayView<char> endpos{};

    int i = findNext(pos, '/', true, true);
    if(i == -1) {
        /* v1 v2 rather than v1/t1 v2/t2 or v1/ v2/ */
        ArrayView<char> word;
        std::tie(word, endpos) = nextWord(pos);
        indices[0] = strToInt(word);
        return std::make_tuple(indices, endpos);
    }

    indices[0] = strToInt(pos.prefix(i));
    endpos = pos.suffix(i+1);

    i = findNext(endpos, ' ', true, true); /* Texture coordinates are not terminated by '/', but ' ' or newline */
    if(i == -1)
        i = findNext(endpos, '\r', true, true);
    if(i == -1)
        i = findNext(endpos, '\n', true, true);

    if(i != -1) { /* There may not be a texCoord! Eg. "1/" */
        auto prefix = endpos.prefix(i);
        if(!prefix.empty()) {
            indices[1] = strToInt(prefix);
            endpos = endpos.suffix(i);
        }
    }

    return std::make_tuple(indices, endpos);
}

// Parse a "v/n/t" string to indices
// Warning: I'm not handing cases like "v/n", where the normal is not terminated by '/', but ' '!
// Same for "v", where even the normal is omitted.
std::tuple<std::array<int, 3>, ArrayView<char>> parseVertex(const ArrayView<char> pos) {
    std::array<int, 3> indices{0, 0, 0};
    ArrayView<char> endpos{};

    int i = findNext(pos, '/', true, true);
    if(i == -1) {
        /* v1 v2 rather than v1/t1 v2/t2 or v1/ v2/ */
        ArrayView<char> word;
        std::tie(word, endpos) = nextWord(pos);
        indices[0] = strToInt(word);
        return std::make_tuple(indices, endpos);
    }

    indices[0] = strToInt(pos.prefix(i));
    endpos = pos.suffix(i+1);

    i = findNext(endpos, '/', true, true);
    if(i != -1) { /* there may not be a normal! Eg. "1//2", in which case the indices of the / are 1 apart */
        auto prefix = endpos.prefix(i);
        if(!prefix.empty()) {
            indices[1] = strToInt(prefix);
        }
        endpos = endpos.suffix(i+1);
    }

    i = findNext(endpos, ' ', true, true); /* texture coordinates are not terminated by '/', but ' ' or newline */
    if(i == -1)
        i = findNext(endpos, '\r', true, true);
    if(i == -1)
        i = findNext(endpos, '\n', true, true);

    if(i != -1) { // there may not be a texCoord! Eg. "1//"
        auto prefix = endpos.prefix(i);
        if(!prefix.empty()) {
            indices[2] = strToInt(prefix);
            endpos = endpos.suffix(i);
        }
    }

    return std::make_tuple(indices, endpos);
}

template<UnsignedInt D>
ArrayView<char> getVector(ArrayView<char> pos, Math::Vector<D, Float>& v) {
    ArrayView<char> word;

    for(int i = 0; i < int(D); ++i) {
        pos = skipWhitespaces(pos);
        std::tie(word, pos) = nextWord(pos);
        v[i] = strToFloat(word);
    }

    return pos;
}

template<class T> std::vector<T> reindex(const std::vector<UnsignedInt>& indices, std::vector<T>& data) {
    /* Check that indices are in range */
    for(UnsignedInt i: indices) if(i >= data.size()) {
        Error() << "Trade::ObjImporter::mesh3D(): index out of range";
        throw 0;
    }

    return MeshTools::duplicate(indices, data);
}

}

ObjImporter::ObjImporter() = default;

ObjImporter::ObjImporter(PluginManager::AbstractManager& manager, const std::string& plugin): AbstractImporter{manager, plugin} {}

ObjImporter::~ObjImporter() = default;

auto ObjImporter::doFeatures() const -> Features { return Feature::OpenData; }

bool ObjImporter::doIsOpened() const { return _in; }

void ObjImporter::doClose() { _in = nullptr; }

void ObjImporter::doOpenFile(const std::string& filename) {
    _fileRoot = filename.substr(0, filename.find_last_of('/')+1);
    AbstractImporter::doOpenFile(filename);
}

void ObjImporter::doOpenData(Containers::ArrayView<const char> data) {
    _in = Containers::Array<char>{data.size()};
    std::copy(data.begin(), data.end(), _in.begin());
    _state.reset(new ImporterState);
    parse();
}

void ObjImporter::parse() {
    ArrayView<char> line = _in; /* points to beginning of current line */
    ArrayView<char> pos = _in;  /* points to current character in line */

    ObjObject* object = nullptr;
    ObjGroup* group = nullptr;
    ObjMeshData* meshData = nullptr;

    ArrayView<char> section{nullptr};
    int minSectionPrimitives = 0;
    char sectionPrimitive = '?';

    /* Set index 0 of data to default value */
    _state->positions.emplace_back();
    _state->normals.emplace_back(); // TODO Default normal?
    _state->texCoords.emplace_back();

    /* Create 'object' if not created by 'o' keyword */
    auto ensureObject = [&]{
        if(object == nullptr) {
            // TODO: C++ 17
            _state->objects.emplace_back(new ObjObject);
            object = _state->objects.back().get();
        }
    };

    /* Create 'group' if not created by 'g' keyword */
    auto ensureGroup = [&]{
        if(group == nullptr) {
            ensureObject();

            // TODO: C++ 17
            object->groups.emplace_back(new ObjGroup{*object});
            group = object->groups.back().get();
        }
    };

    /* Create 'meshData' if not created by 'usemtl' keyword */
    auto ensureMeshData = [&](){
        if(meshData == nullptr) {
            ensureGroup();
            meshData = &group->meshDataForMaterial(-1);
        }
    };

    /* Close a section and add it to the current meshData */
    auto finishSection = [&]{
        if(section.data() == nullptr) {
            /* No open section */
            return;
        }

        ensureMeshData();

        ObjMesh* mesh;
        if(sectionPrimitive == 'p') {
            if(!meshData->points) {
                // TODO: C++ 17
                _state->meshes.emplace_back(new ObjMesh{*meshData, MeshPrimitive::Points});
                meshData->points = _state->meshes.back().get();
            }
            mesh = meshData->points;
        } else if(sectionPrimitive == 'l') {
            if(!meshData->lines) {
                // TODO: C++ 17
                _state->meshes.emplace_back(new ObjMesh{*meshData, MeshPrimitive::Lines});
                meshData->lines = _state->meshes.back().get();
            }
            mesh = meshData->lines;
        } else { /* sectionPrimitive == 'f' */
            if(!meshData->faces) {
                // TODO: C++ 17
                _state->meshes.emplace_back(new ObjMesh{*meshData, MeshPrimitive::Triangles});
                meshData->faces = _state->meshes.back().get();
            }
            mesh = meshData->faces;
        }
        if(line.data() == nullptr) {
            /* Usually for the last line */
            mesh->sections.push_back(section);
        } else {
            mesh->sections.emplace_back(section.data(), size_t(line.data()-section.data()));
        }
        mesh->minPrimitives += minSectionPrimitives;

        section = {nullptr};
        minSectionPrimitives = 0;
    };

    auto finishObject = [&]{
        if(object && object->groups.empty()) {
            /* Create dummy mesh for this object so that it gets loaded as ObjectData */
            _state->meshlessObjects.push_back(object->name);
        }
    };

    while(!pos.empty()) {

        /* Comment line */
        if(pos[0] == '#') {
            finishSection();
            line = pos = skipWhitespaces(ignoreLine(pos));
            continue;
        }

        /* Parse the keyword */
        std::string keyword;
        ArrayView<char> word;
        std::tie(word, pos) = nextWord(pos);
        keyword = std::string(word.data(), word.size());

        pos = skipWhitespaces(pos);
        bool sectionEnd = true;

        /* Vertex position */
        if(keyword == "v") {
            // TODO C++17: Could be one slick line with emplace_back ref return.
            Vector3 v;
            pos = getVector<3>(pos, v);
            _state->positions.push_back(v);
        /* Texture coordinate */
        } else if(keyword == "vt") {
            // TODO C++17: Could be one slick line with emplace_back ref return.
            Vector2 tc;
            pos = getVector<2>(pos, tc);
            _state->texCoords.push_back(tc);

        /* Normal */
        } else if(keyword == "vn") {
            // TODO C++17: Could be one slick line with emplace_back ref return.
            Vector3 n;
            pos = getVector<3>(pos, n);
            _state->normals.push_back(n);

        /* Indices */
        } else if(keyword == "f" || keyword == "l" || keyword == "p") {
            sectionEnd = false;

            if(sectionPrimitive != keyword[0]) {
                /* Create new section, mixed primitives! */
                finishSection();
            }

            if(section.data() == nullptr) {
                /* Create new section */
                section = line;
                sectionPrimitive = keyword[0];
            }

            ++minSectionPrimitives;

        /* Object name */
        } else if(keyword == "o") {
            finishSection();
            finishObject();

            ArrayView<char> name;
            std::tie(name, pos) = nextWord(pos);

            _state->objects.emplace_back(new ObjObject{name});
            object = _state->objects.back().get();
            group = nullptr;
            meshData = nullptr;

        /* Object group */
        } else if(keyword == "g") {
            //TODO: Handle geometry shared by multiple groups, e.g. g group1 group2
            ensureObject();
            object->groups.emplace_back(new ObjGroup{*object});
            group = object->groups.back().get();

            meshData = nullptr;

            ArrayView<char> name;
            std::tie(name, pos) = nextWord(pos);
            group->name = std::string{name.data(), name.size()};

        /* Load a material library */
        } else if(keyword == "mtllib") {
            ArrayView<char> word;
            pos = skipWhitespaces(pos);
            std::tie(word, pos) = nextWord(pos);

            parseMaterialLibrary(word);

        /* Set current material and add a new mesh for it */
        } else if(keyword == "usemtl") {
        ArrayView<char> word;
        pos = skipWhitespaces(pos);
            std::tie(word, pos) = nextWord(pos);

            const int materialIndex = _state->materialIds[std::string{word.data(), word.size()}];
            if(meshData == nullptr || materialIndex != meshData->materialId) {
                /* Switching the material here, need to create a new mesh */
                //TODO C++17
                ensureGroup();
                meshData = &group->meshDataForMaterial(materialIndex);
            } // else: usemtl did not result in material switch, no need to create new mesh

        /* Ignore unsupported keywords, error out on unknown keywords */
        } else {
            Warning() << "Trade::ObjImporter::parse(): unknown keyword:" << keyword;
        }

        if(sectionEnd) {
            finishSection();
        }

        /* Ignore the rest of the line */
        line = pos = skipWhitespaces(ignoreLine(pos));
    }

    finishSection();
    finishObject();

    int i = _state->meshes.size();
    for(auto name : _state->meshlessObjects) {
        _state->meshlessObjectIds[name] = i++;
    }
}

void ObjImporter::parseMaterialLibrary(const ArrayView<char> libname) {
    std::string filename = _fileRoot + std::string(libname.data(), libname.size());

    /* Open file */
    if(!Utility::Directory::fileExists(filename)) {
        Error() << "Trade::AbstractImporter::parseMaterialLibrary(): cannot open file" << filename;
        return;
    }

    Containers::Array<char> contents = Utility::Directory::read(filename);
    ArrayView<char> pos = contents;  /* points to current character in line */

    ObjMaterial* mat = nullptr;

    while(!pos.empty()) {

        /* Comment line */
        if(pos[0] == '#') {
            pos = ignoreLine(pos);
            pos = skipWhitespaces(pos);
            continue;
        }

        /* Parse the keyword */
        ArrayView<char> word;
        std::tie(word, pos) = nextWord(pos);
        std::string keyword{word.data(), word.size()};

        if(keyword.empty()) {
            pos = skipWhitespaces(pos);
            continue;
        }

        pos = skipWhitespaces(pos);

        if(keyword == "newmtl") {
            std::tie(word, pos) = nextWord(pos);

            _state->materials.emplace_back();
            mat = &_state->materials.back();
            mat->name = std::string{word.data(), word.size()};

            _state->materialIds[mat->name] = _state->materials.size()-1;
            continue;
        } else if (mat == nullptr) {
            Error() << "Expected newmtl keyword, got" << keyword;
        }

        /* Ambient color */
        if(keyword == "Ka") {
            ArrayView<char> word;

            for(int i : {0, 1, 2}) {
                std::tie(word, pos) = nextWord(pos);
                mat->ambient[i] = strToFloat(word);
            }

        /* Diffuse color */
        } else if(keyword == "Kd") {
            ArrayView<char> word;

            for(int i : {0, 1, 2}) {
                std::tie(word, pos) = nextWord(pos);
                mat->diffuse[i] = strToFloat(word);
            }

        /* Specular color */
        } else if(keyword == "Ks") {
            ArrayView<char> word;

            for(int i : {0, 1, 2}) {
                std::tie(word, pos) = nextWord(pos);
                mat->specular[i] = strToFloat(word);
            }

        /* Specularity */
        } else if(keyword == "Ns") {
            ArrayView<char> word;

            std::tie(word, pos) = nextWord(pos);
            const float f = strToFloat(word);

            mat->specularity = f;
        /* Ambient texture */
        } else if(keyword.substr(0, 4) == "map_") {
            ArrayView<char> line;
            std::tie(line, pos) = nextLine(pos);
            std::string texture{line.data(), line.size()};

            int textureId = -1;
            if(_state->textureIds.find(texture) == _state->textureIds.end()) {
                /* new texture, create it */
                int index = _state->textures.size();
                _state->textures.push_back(texture);

                _state->textureIds[texture] = index;
                textureId = index;
            } else {
                textureId = _state->textureIds[texture];
            }

            auto suffix = keyword.substr(4, 2);
            if(suffix == "Kd") {
                mat->diffuseTexture = textureId;
            } else if(suffix == "Ka") {
                mat->ambientTexture = textureId;
            } else if(suffix == "Ks") {
                mat->specularTexture = textureId;
            } else {
                Warning() << "Trade::ObjImporter::parseMaterialLibrary(): unsupported texture type:" << suffix;
            }

        /* Ignore unsupported keywords, error out on unknown keywords */
        } else {
            Warning() << "Trade::ObjImporter::parseMaterialLibrary(): unknown keyword:" << keyword;
        }

        /* Ignore the rest of the line */
        pos = skipWhitespaces(ignoreLine(pos));
    }
}

UnsignedInt ObjImporter::doMesh3DCount() const { return _state->meshes.size(); }

UnsignedInt ObjImporter::doMaterialCount() const { return _state->materials.size(); }

UnsignedInt ObjImporter::doImage2DCount() const { return _state->textures.size(); }

UnsignedInt ObjImporter::doObject3DCount() const { return _state->meshes.size() + _state->meshlessObjects.size(); }

Int ObjImporter::doObject3DForName(const std::string& name) {
    auto result = _state->meshlessObjectIds.find(name);
    if(result != _state->meshlessObjectIds.end()) {
        return result->second;
    }

    result = _state->meshIds.find(name);
    if(result != _state->meshIds.end()) {
        return result->second;
    }

    return -1;
}

std::string ObjImporter::doObject3DName(UnsignedInt id) {
    const size_t numMeshes = _state->meshes.size();
    if(id >= numMeshes) {
        return _state->meshlessObjects[id - numMeshes];
    }
    return _state->meshes[id]->name(); /* Intentional, objects are just meshes + material */
}

std::unique_ptr<ObjectData3D> ObjImporter::doObject3D(UnsignedInt id) {
    const size_t numMeshes = _state->meshes.size();
    if(id > numMeshes) {
        return std::unique_ptr<ObjectData3D>{new ObjectData3D{{}, {}, &_state->meshlessObjects[id - numMeshes]}};
    }
    const ObjMesh& mesh = *_state->meshes[id];
    return std::unique_ptr<ObjectData3D>{
        new MeshObjectData3D{{}, {}, id, mesh.data.materialId, _state->meshes[id].get()}};
}

Int ObjImporter::doMesh3DForName(const std::string& name) {
    return _state->meshIds[name];
}

std::string ObjImporter::doMesh3DName(UnsignedInt id) {
    return _state->meshes[id]->name();
}

std::optional<MeshData3D> ObjImporter::doMesh3D(UnsignedInt id) {
    const ObjMesh& mesh = *_state->meshes[id];

    const int primitiveSize = (mesh.primitive == MeshPrimitive::Triangles)
        ? 3 : ((mesh.primitive == MeshPrimitive::Lines) ? 2 : 1);

    std::vector<UnsignedInt> positionIndices;
    std::vector<UnsignedInt> normalIndices;
    std::vector<UnsignedInt> textureCoordinateIndices;

    positionIndices.reserve(mesh.minPrimitives*primitiveSize);
    if(primitiveSize >= 2) {
        /* Only need to allocate texCoords for lines and faces */
        textureCoordinateIndices.reserve(mesh.minPrimitives*primitiveSize);
        if(primitiveSize == 3) {
            /* Only need to allocate normals for faces */
            normalIndices.reserve(mesh.minPrimitives*primitiveSize);
        }
    }

    // TODO set to true on first non (-1) encounter
    bool hasNormals = false;
    bool hasTexCoords = false;

    for(auto section : mesh.sections) {
        auto pos = skipWhitespaces(section);

        switch(mesh.primitive) {
            case MeshPrimitive::Triangles:
                while(!pos.empty()) {
                    CORRADE_ASSERT(pos[0] == 'f' && pos[1] == ' ', "Unexpected primitive keyword for Triangles", {});
                    pos = pos.suffix(2);

                    for(int i = 0; i < 3; ++i) {
                        std::array<int, 3> vertex;
                        std::tie(vertex, pos) = parseVertex(pos);
                        positionIndices.push_back(vertex[0]);
                        textureCoordinateIndices.push_back(vertex[1]);
                        normalIndices.push_back(vertex[2]);

                        hasTexCoords = hasTexCoords || (vertex[1] != 0);
                        hasNormals = hasNormals || (vertex[2] != 0);

                        pos = skipWhitespaces(pos, false);
                    }
                    pos = skipWhitespaces(ignoreLine(pos));
                }
                break;
            case MeshPrimitive::Lines:
                while(!pos.empty()) {
                    CORRADE_ASSERT(pos[0] == 'l' && pos[1] == ' ', "Unexpected primitive keyword for Lines", {});
                    pos = pos.suffix(2);

                    while(!atEndOfLine(pos)) {
                        std::array<int, 2> line;
                        std::tie(line, pos) = parseLine(pos);
                        positionIndices.push_back(line[0]);
                        textureCoordinateIndices.push_back(line[1]);

                        hasTexCoords = hasTexCoords || (line[1] != 0);

                        pos = skipWhitespaces(pos, false);
                    }
                    pos = skipWhitespaces(ignoreLine(pos));
                }
                break;
            case MeshPrimitive::Points:
                while(!pos.empty()) {
                    CORRADE_ASSERT(pos[0] == 'p' && pos[1] == ' ', "Unexpected primitive keyword for Points", {});
                    pos = pos.suffix(2);

                    ArrayView<char> word;
                    while(!atEndOfLine(pos)) {
                        std::tie(word, pos) = nextWord(pos);
                        positionIndices.push_back(strToInt(word));
                        pos = skipWhitespaces(pos, false);
                    }
                    pos = skipWhitespaces(ignoreLine(pos));
                }
                break;
            default:
                CORRADE_ASSERT_UNREACHABLE();
        }
    }

    /* Merge index arrays, if there aren't just the positions */
    std::vector<UnsignedInt> indices;

    std::vector<std::vector<Vector3>> positionLayers;
    std::vector<std::vector<Vector3>> normalLayers;
    std::vector<std::vector<Vector2>> texCoordLayers;

    std::vector<std::reference_wrapper<std::vector<UnsignedInt>>> arrays;
    arrays.reserve(3);
    arrays.emplace_back(positionIndices);
    if(hasNormals) arrays.emplace_back(normalIndices);
    if(hasTexCoords) arrays.emplace_back(textureCoordinateIndices);
    indices = MeshTools::combineIndexArrays(arrays);

    /* Reindex data arrays */
    try {
        positionLayers.push_back(reindex(positionIndices, _state->positions));
        if(hasNormals) normalLayers.push_back(reindex(normalIndices, _state->normals));
        if(hasTexCoords) texCoordLayers.push_back(reindex(textureCoordinateIndices, _state->texCoords));
    } catch(...) {
        /* Error message already printed */
        return std::nullopt;
    }

    return MeshData3D(mesh.primitive, std::move(indices), std::move(positionLayers),
            std::move(normalLayers), std::move(texCoordLayers), {}, &mesh);
}

std::unique_ptr<AbstractMaterialData> ObjImporter::doMaterial(const UnsignedInt id) {
    ObjMaterial& objMat = _state->materials[id];
    PhongMaterialData::Flags flags;

    if(objMat.ambientTexture != -1) {
        flags |= PhongMaterialData::Flag::AmbientTexture;
    }
    if(objMat.diffuseTexture != -1) {
        flags |= PhongMaterialData::Flag::DiffuseTexture;
    }
    if(objMat.specularTexture != -1) {
        flags |= PhongMaterialData::Flag::SpecularTexture;
    }

    PhongMaterialData* mat = new PhongMaterialData{
            flags,
            objMat.specularity};

    if(objMat.ambientTexture == -1) {
        mat->ambientColor() = objMat.ambient;
    } else {
        mat->ambientTexture() = objMat.ambientTexture;
    }

    if(objMat.diffuseTexture == -1) {
        mat->diffuseColor() = objMat.diffuse;
    } else {
        mat->diffuseTexture() = objMat.diffuseTexture;
    }

    if(objMat.specularTexture == -1) {
        mat->specularColor() = objMat.specular;
    } else {
        mat->specularTexture() = objMat.specularTexture;
    }

    return std::unique_ptr<AbstractMaterialData>(mat);
}

std::optional<ImageData2D> ObjImporter::doImage2D(UnsignedInt id) {
    CORRADE_ASSERT(manager(), "Trade::ObjImporter::image2D(): the plugin must be instantiated with access to plugin manager in order to open image files", {});

    std::unique_ptr<AbstractImporter> imageImporter = manager()->loadAndInstantiate("TgaImporter"); // probably AnyImageImporter would be the way to go here...
    if(!imageImporter->openFile(_fileRoot + _state->textures[id])) {
        return std::nullopt;
    }

    return imageImporter->image2D(0);
}


}}
